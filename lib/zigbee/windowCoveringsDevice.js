"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const zigbee_clusters_1 = require("zigbee-clusters");
const valueRange_1 = __importDefault(require("./helper/valueRange"));
const UP_OPEN = 'upOpen';
const DOWN_CLOSE = 'downClose';
const LIFT_PERCENTAGE = 'currentPositionLiftPercentage';
const SET_CAPABILITY = 'windowcoverings_set';
const STOP_CAPABILITY = 'windowcoverings_stop';
const CLUSTER_SPEC = zigbee_clusters_1.CLUSTER.WINDOW_COVERING;
const REPORT_DEBOUNCE_TIME = 5000;
async function initWindowCoveringsDevice(device, zclNode) {
    if (!device.hasCapability(SET_CAPABILITY)) {
        return;
    }
    device.log(`Initialising ${SET_CAPABILITY} capability`);
    const endpoint = device.getClusterEndpoint(CLUSTER_SPEC) ?? 1;
    const cluster = zclNode
        .endpoints[endpoint]
        .clusters[CLUSTER_SPEC.NAME];
    const setParser = async function (value) {
        device.debug(`Newly set value for ${SET_CAPABILITY}`, value);
        // Refresh timer or set new timer to prevent reports from updating the dim slider directly
        // when set command from Homey
        if (device.positionPercentageDebounce) {
            device.positionPercentageDebounce.refresh();
        }
        else {
            device.positionPercentageDebounce = device.homey.setTimeout(() => {
                device.positionPercentageDebounceEnabled = false;
                device.positionPercentageDebounce = null;
            }, REPORT_DEBOUNCE_TIME);
        }
        // Used to check if reports are generated based on set command from Homey
        device.positionPercentageDebounceEnabled = true;
        // Override goToLiftPercentage to enforce blind to open/close completely
        if (value === 0 || value === 1) {
            const windowCoveringCommand = value === 1 ? UP_OPEN : DOWN_CLOSE;
            device.debug(`set → \`windowcoverings_set\`: ${value} → setParser → ${windowCoveringCommand}`);
            await cluster[windowCoveringCommand]();
            await device.setCapabilityValue('windowcoverings_set', value);
            return null;
        }
        const mappedValue = (0, valueRange_1.default)(0, 1, 0, 100, value);
        const gotToLiftPercentageCommand = {
            // Round, otherwise might not be accepted by device
            percentageLiftValue: Math.round(mappedValue),
        };
        device.debug(`set → \`${SET_CAPABILITY}\`: ${value} → setParser → goToLiftPercentage`, gotToLiftPercentageCommand);
        // Send command
        return gotToLiftPercentageCommand;
    };
    const reportParser = function (value) {
        device.debug(`Newly reported value for ${SET_CAPABILITY}`, value);
        // Validate input
        if (value < 0 || value > 100) {
            return null;
        }
        // Parse input value
        const parsedValue = (0, valueRange_1.default)(0, 100, 0, 1, value);
        // Refresh timer if needed
        if (device.positionPercentageDebounce) {
            device.positionPercentageDebounce.refresh();
        }
        // If reports are not generated by set command from Homey update directly
        if (!device.positionPercentageDebounceEnabled) {
            return parsedValue;
        }
        // Return default
        return null;
    };
    // Retrieve initial values
    await readPercentageValue(device, cluster, reportParser);
    // Configure the capability
    device.registerCapability(SET_CAPABILITY, CLUSTER_SPEC, {
        getOpts: {
            getOnStart: false,
        },
        get: 'currentPositionLiftPercentage',
        set: 'goToLiftPercentage',
        setParser,
        report: 'currentPositionLiftPercentage',
        reportParser,
    });
    device.log(`Initialised ${SET_CAPABILITY} capability`);
    // Check for stop support, if so
    if (device.hasCapability(STOP_CAPABILITY)) {
        device.log(`Initialising ${STOP_CAPABILITY} capability`);
        device.registerCapabilityListener(STOP_CAPABILITY, async () => {
            // Execute the command
            await cluster.stop();
            // Clear the timeout (if still running
            if (device.positionPercentageDebounce) {
                device.positionPercentageDebounceEnabled = false;
                device.homey.clearTimeout(device.positionPercentageDebounce);
                device.positionPercentageDebounce = null;
            }
            // Retrieve new position value
            await readPercentageValue(device, cluster, reportParser);
        });
        device.log(`Initialised ${STOP_CAPABILITY} capability`);
    }
}
exports.default = initWindowCoveringsDevice;
async function readPercentageValue(device, cluster, reportParser) {
    await cluster
        .readAttributes(LIFT_PERCENTAGE)
        .then(async (result) => {
        await device
            .setCapabilityValue(SET_CAPABILITY, reportParser(result[LIFT_PERCENTAGE]))
            .catch(e => device.error(`Failed to set ${SET_CAPABILITY} capability value`, e));
    })
        .catch(e => device.error(`Failed to read ${CLUSTER_SPEC.NAME} ${LIFT_PERCENTAGE} attribute`, e));
}
//# sourceMappingURL=windowCoveringsDevice.js.map